// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GetDeadBlocks
#pragma kernel AssignBlockProperties
#pragma kernel GetDeadCells
#pragma kernel AddCells
#pragma kernel FlushGridData
#pragma kernel UpdateGridDataAtIndex
#pragma kernel FlushBlockBounds
#pragma kernel UpdateBlockBoundsAndOtherEndPhaseData
#pragma kernel UpdateBlockCentersAndMaxBlockBound
#pragma kernel UpdatePlayerAimReticles
#pragma kernel GetBlockCenterCellDistance
#pragma kernel GetBlockCenterGridID
#pragma kernel GetBlockCenterCell
#pragma kernel ResetCellConnctionsToCenter
#pragma kernel ConnectCellToCenter
#pragma kernel DestroyDisconnectedCells
#pragma kernel TickBlock
#pragma kernel SetVelocityById
#pragma kernel SetRotationById
#pragma kernel CheckBlockCollisions
#pragma kernel UpdateAttatchBlockID
#pragma kernel AttatchBlockCells
#pragma kernel MoveCells
#pragma kernel PostMoveKillNonMatchingCells
#pragma kernel PostMoveKillOutgoingCells
#pragma kernel ResetBlockDeathAndMove
#pragma kernel RefreshBlockDeath
#pragma kernel Detonate
#pragma kernel ClearDisplay
#pragma kernel DisplayCells
#pragma kernel DisplayCenterPins
#pragma kernel LerpCells
#pragma kernel DisplayDyingCells
#pragma kernel DisplayAimReticle
#pragma kernel DisplayBlockDebug

struct BlockStruct
{
	int ID;
	int creationID;
	int type;
	int subType;
	int dead;
	int left;
	int right;
	int up;
	int down;
	int centerX;
	int centerY;
	int velocityX;
	int velocityY;
	int moveTicks;
	int currentTick;
	int canMove;
	int attachToBlockId;
    int attatched;
    int absorbPriority;
    int absorbType;
    int ignoreType;
    int canAbsorb;
    int CanBeAbsorbed;
    int KillNonMatching;
    int KillableByNonMatching;
    int centerCellSquareDistance;
    int centerGridID;
    int centerCellID;
    int rotateDirection;
    int aboutToDie;
    int isGrenade;
    int cellCount;
};

struct CellStruct
{
	int ID;
	int gridPosX;
	int gridPosY;
	int parentBlockID;
	int dying;
	int dead;
	int left;
	int right;
	int up;
	int down;
    int rotTicks;
    float lastX;
    float lastY;
    int connectedToCenter;
    int isImpactDeath;
    float velocityX;
    float velocityY;
    float timeSinceImpact;
};

struct GridCell
{
    int cells [10];
};

struct VelocityData
{
    int blockId;
    int velocityX;
    int velocityY;
    int rotationDirection;
};

struct PlayerAimData
{
    int directions[9];
};

RWTexture2D<float4> Result;
RWTexture2D<float4> DebugResult;
Texture2D<float4> cellSprite;
SamplerState sampler_cellSprite;
Texture2D<float4> debugSprite;
SamplerState sampler_debugSprite;
Texture2D<float4> arrowSprite;
SamplerState sampler_arrowSprite;
Texture2D<float4> reticleSprite;
SamplerState sampler_reticleSprite;
int scalingFactor;

// Core grid params
int width;
int height;
int blockPoolHead;
RWStructuredBuffer<BlockStruct> blockBuffer : register(u1);
RWStructuredBuffer<CellStruct> cellBuffer : register(u2);
RWStructuredBuffer<GridCell> grid : register(u3);

//Player params
int player1ID;
float aimArrowNormalizedSize;
RWStructuredBuffer<PlayerAimData> playerAimData : register(u11);
int2 aimDirection;

// Shape Check params
RWStructuredBuffer<int2> shapeToCheck : register(u12);

//PowerUp Params
int detonationRadius;

// Time 
float deltaTime;
float random1;
float random100;
float randomMinusOneToOne;

// Add Block Params
int newCreationID;
int newBlockOffsetX;
int newBlockOffsetY;
int spawnRelativeBlockID;
uint newType;
uint newSubType;
int newVelocityX;
int newVelocityY;
int newMoveTicks;
int newAbsorbPriority;
int newAbsorbType;
int newIgnoreType;
int newCanAbsorb;
int newCanBeAbsorbed;
int newKillNonMatching;
int newKillableByNonMatching;
int newIsGrenade;
RWStructuredBuffer<int2> newCells : register(u10);
AppendStructuredBuffer<int2> attatchBlocksBuffer : register(u6);
RWStructuredBuffer<int2> attatchBlocksBufferCurated : register(u7);

// Update Grid Data Params
int gridCellIndex;

// Dead Pool
AppendStructuredBuffer<int> deadBlocksBuffer : register(u4);
AppendStructuredBuffer<int> deadCellsBuffer : register(u5);
RWStructuredBuffer<int> deadBlocksCurated : register(u4);
RWStructuredBuffer<int> deadCellsCurated : register(u5);
RWStructuredBuffer<int> newBlockId;

// Disconnected Cells Params
RWStructuredBuffer<int2> maxBlockBounds : register(u8);

//Velocity Data Buffer
RWStructuredBuffer<VelocityData> setVelocityBuffer : register(u9);

// Some helper functions
float4 GetColorFromType(int blockType)
{
	if (blockType == 1)
	{
		return float4(1, 0, 0, 1);
	}
	if (blockType == 2)
	{
		return float4(0, 1, 0, 1);
	}
	if (blockType == 3)
	{
		return float4(0, 0, 1, 1);
	}
	if (blockType == 4)
	{
		return float4(1, 0.75, 0.016, 1);
	}

	return float4(1, 1, 1, 1);
}

bool InGridBounds(float x, float y)
{
	return x >= 0 && x < width && y >= 0 && y < height;
}

float InGridBoundsInt(float x, float y)
{
    float xVal = x * (x - (width - 1));
    float xRet = (abs(xVal) - sign(xVal)) / 2;
    float yVal = y * (y - (height - 1));
    float yRet = (abs(yVal) - sign(yVal)) / 2;
    return xRet * yRet;
}

bool InGridBoundsPadded(float x, float y, float padding)
{
    return x >= -padding && x < width + padding && y >= -padding && y < height + padding;
}

uint rand_lcg(uint rng_state)
{
    // LCG values from Numerical Recipes
    rng_state = 1664525 * rng_state + 1013904223;
    return rng_state;
}

// Kernels
[numthreads(64, 1, 1)]
void GetDeadBlocks(uint3 id : SV_DispatchThreadID)
{
	int blockId = id.x;
	if (blockBuffer[blockId].dead == 0)
	{
		deadBlocksBuffer.Append(blockId);
	}
}

[numthreads(1, 1, 1)]
void AssignBlockProperties(uint3 id : SV_DispatchThreadID)
{
    // Set Buffer
    newBlockId[0] = deadBlocksCurated[0];
    // Set CONSTS
    blockBuffer[deadBlocksCurated[0]].ID = deadBlocksCurated[0];
	blockBuffer[deadBlocksCurated[0]].type = newType;
	blockBuffer[deadBlocksCurated[0]].subType = newSubType;
	blockBuffer[deadBlocksCurated[0]].velocityX = newVelocityX;
	blockBuffer[deadBlocksCurated[0]].velocityY = newVelocityY;
	blockBuffer[deadBlocksCurated[0]].moveTicks = newMoveTicks;
	blockBuffer[deadBlocksCurated[0]].creationID = newCreationID;
    blockBuffer[deadBlocksCurated[0]].absorbPriority = newAbsorbPriority;
    blockBuffer[deadBlocksCurated[0]].absorbType = newAbsorbType;
    blockBuffer[deadBlocksCurated[0]].ignoreType = newIgnoreType;
    blockBuffer[deadBlocksCurated[0]].canAbsorb = newCanAbsorb;
    blockBuffer[deadBlocksCurated[0]].CanBeAbsorbed = newCanBeAbsorbed;
    blockBuffer[deadBlocksCurated[0]].KillNonMatching = newKillNonMatching;
    blockBuffer[deadBlocksCurated[0]].KillableByNonMatching = newKillableByNonMatching;
    blockBuffer[deadBlocksCurated[0]].isGrenade = newIsGrenade;
    // Set Initializers
    blockBuffer[deadBlocksCurated[0]].currentTick = 0;
    blockBuffer[deadBlocksCurated[0]].canMove = 0;
    blockBuffer[deadBlocksCurated[0]].attachToBlockId = -1;
    blockBuffer[deadBlocksCurated[0]].centerCellSquareDistance = 10000;
    blockBuffer[deadBlocksCurated[0]].centerGridID = width * height + 10000;
    blockBuffer[deadBlocksCurated[0]].centerCellID = -1;
    blockBuffer[deadBlocksCurated[0]].centerX = 0;
    blockBuffer[deadBlocksCurated[0]].centerY = 0;
    blockBuffer[deadBlocksCurated[0]].cellCount = 0;
    blockBuffer[deadBlocksCurated[0]].aboutToDie = 0;
	blockBuffer[deadBlocksCurated[0]].dead = 1;
}

[numthreads(64, 1, 1)]
void GetDeadCells(uint3 id : SV_DispatchThreadID)
{
	int cellId = id.x;
    if (cellBuffer[cellId].dead == 0 && cellBuffer[cellId].dying == 0)
	{
		deadCellsBuffer.Append(cellId);
	}
}

[numthreads(64, 1, 1)]
void AddCells(uint3 id : SV_DispatchThreadID)
{
	int cellId = deadCellsCurated[id.x];
    int relativeBlockX = 0;
    int relativeBlockY = 0;
    if(spawnRelativeBlockID > -1)
    {
        relativeBlockX = blockBuffer[spawnRelativeBlockID].centerX;
        relativeBlockY = blockBuffer[spawnRelativeBlockID].centerY;
    }
	if (newCells[id.x].x >= -1000)
	{
		cellBuffer[cellId].ID = cellId;
		cellBuffer[cellId].gridPosX = newCells[id.x].x + relativeBlockX - newBlockOffsetX;
        cellBuffer[cellId].gridPosY = newCells[id.x].y + relativeBlockY - newBlockOffsetY;
        cellBuffer[cellId].lastX = (newCells[id.x].x + relativeBlockX - newBlockOffsetX) * scalingFactor;
        cellBuffer[cellId].lastY = (newCells[id.x].y + relativeBlockY - newBlockOffsetY) * scalingFactor;
		cellBuffer[cellId].parentBlockID = deadBlocksCurated[0];
		cellBuffer[cellId].dead = 1;
        cellBuffer[cellId].dying = 0;
        cellBuffer[cellId].rotTicks = 0;
        cellBuffer[cellId].connectedToCenter = 0;
        cellBuffer[cellId].isImpactDeath = 0;
    }	
}

[numthreads(64, 9, 1)]
void FlushGridData(uint3 id : SV_DispatchThreadID)
{
	int gridId = width * id.y + id.x;
    for (int i = 0; i < 10; i++)
    {
        grid[gridId].cells[i] = -1;
    }
}

[numthreads(64, 1, 1)]
void UpdateGridDataAtIndex(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
    if (cellBuffer[cellId].dead == 1 && InGridBounds(cellBuffer[cellId].gridPosX, cellBuffer[cellId].gridPosY))
    {
        int gridId = width * cellBuffer[cellId].gridPosY + cellBuffer[cellId].gridPosX;
        int alreadyRegistered = 0;
        if(gridCellIndex > 0)
        {
            for (int i = 0; i < gridCellIndex; i++)
            {
                if (grid[gridId].cells[i] == cellId)
                {
                    alreadyRegistered = 1;
                }
            }               
        }  
        if (alreadyRegistered == 0)
        {
            int temp;
            InterlockedExchange(grid[gridId].cells[gridCellIndex], (int) cellId, temp);
        }
    }
}

[numthreads(64, 1, 1)]
void FlushBlockBounds(uint3 id : SV_DispatchThreadID)
{
	int blockId = id.x;
	blockBuffer[blockId].left = 10000;
	blockBuffer[blockId].right = -10000;
	blockBuffer[blockId].up = -10000;
	blockBuffer[blockId].down = 10000;
    blockBuffer[blockId].attachToBlockId = -1;
    blockBuffer[blockId].centerCellSquareDistance = 10000;
    blockBuffer[blockId].centerGridID = width * height + 10000;
    blockBuffer[blockId].centerCellID = -1;
    blockBuffer[blockId].centerX = 0;
    blockBuffer[blockId].centerY = 0;
    blockBuffer[blockId].cellCount = 0;
    maxBlockBounds[0].x = 0;
    maxBlockBounds[0].y = 0;
    for (int i = 0; i < 9; i++)
    {
        playerAimData[0].directions[i] = max(width, height);
    }
}

[numthreads(64, 1, 1)]
void UpdateBlockBoundsAndOtherEndPhaseData(uint3 id : SV_DispatchThreadID)
{
	int cellId = id.x;
	if (cellBuffer[cellId].dead == 1)
	{
		int temp;
		InterlockedMin(blockBuffer[cellBuffer[cellId].parentBlockID].left, (int)cellBuffer[cellId].gridPosX, temp);
		InterlockedMax(blockBuffer[cellBuffer[cellId].parentBlockID].right, (int)cellBuffer[cellId].gridPosX, temp);
		InterlockedMax(blockBuffer[cellBuffer[cellId].parentBlockID].up, (int)cellBuffer[cellId].gridPosY, temp);
		InterlockedMin(blockBuffer[cellBuffer[cellId].parentBlockID].down, (int)cellBuffer[cellId].gridPosY, temp);

        InterlockedAdd((int) blockBuffer[cellBuffer[cellId].parentBlockID].centerX, (int) cellBuffer[cellId].gridPosX);
        InterlockedAdd((int) blockBuffer[cellBuffer[cellId].parentBlockID].centerY, (int) cellBuffer[cellId].gridPosY);
        InterlockedAdd((int) blockBuffer[cellBuffer[cellId].parentBlockID].cellCount, 1);

        //CellStruct cell = cellBuffer[cellId];
        //BlockStruct playerBlock = blockBuffer[player1ID];
        //int2 deltaOffset = int2(cell.gridPosX - playerBlock.centerX, cell.gridPosY - playerBlock.centerY);
        //if ((deltaOffset.x == 0 || deltaOffset.y == 0 || abs(deltaOffset.x) == abs(deltaOffset.y)) && cell.parentBlockID != player1ID)
        //{
        //    int2 deltaOffsetNorm = int2(sign(deltaOffset.x), sign(deltaOffset.y));
        //    int directionId = 3 * (deltaOffsetNorm.y + 1) + deltaOffsetNorm.x + 1;
        //    InterlockedMin(playerAimData[0].directions[directionId], max(abs(deltaOffset.x), abs(deltaOffset.y)));
            
        //}       
    }
}

[numthreads(64, 1, 1)]
void UpdateBlockCentersAndMaxBlockBound(uint3 id : SV_DispatchThreadID)
{
	int blockId = id.x;
    // HACK to make sure only non empty blocks are checked, because dead set happens later
    if (blockBuffer[blockId].dead == 1 && blockBuffer[blockId].left != 10000)
	{
		//blockBuffer[blockId].centerX = floor((blockBuffer[blockId].left + blockBuffer[blockId].right) * 0.5);
        //blockBuffer[blockId].centerY = floor((blockBuffer[blockId].up + blockBuffer[blockId].down) * 0.5);
        blockBuffer[blockId].centerX = floor((float)blockBuffer[blockId].centerX / (float)blockBuffer[blockId].cellCount);
        blockBuffer[blockId].centerY = floor((float)blockBuffer[blockId].centerY / (float)blockBuffer[blockId].cellCount);
        InterlockedMax(maxBlockBounds[0].x, (int) (blockBuffer[blockId].right - blockBuffer[blockId].left));
        InterlockedMax(maxBlockBounds[0].y, (int) (blockBuffer[blockId].up - blockBuffer[blockId].down));
    }
}

[numthreads(64, 1, 1)]
void UpdatePlayerAimReticles(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
    if (cellBuffer[cellId].dead == 1)
    {
        CellStruct cell = cellBuffer[cellId];
        BlockStruct playerBlock = blockBuffer[player1ID];
        int2 deltaOffset = int2(cell.gridPosX - playerBlock.centerX, cell.gridPosY - playerBlock.centerY);
        if ((deltaOffset.x == 0 || deltaOffset.y == 0 || abs(deltaOffset.x) == abs(deltaOffset.y)) && cell.parentBlockID != player1ID)
        {
            int2 deltaOffsetNorm = int2(sign(deltaOffset.x), sign(deltaOffset.y));
            int directionId = 3 * (deltaOffsetNorm.y + 1) + deltaOffsetNorm.x + 1;
            InterlockedMin(playerAimData[0].directions[directionId], max(abs(deltaOffset.x), abs(deltaOffset.y)));           
        }
    }
}

[numthreads(64, 1, 1)]
void GetBlockCenterCellDistance(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
    CellStruct cell = cellBuffer[cellId];
    if (cell.dead == 1)
    {
        int temp;
        BlockStruct block = blockBuffer[cellBuffer[cellId].parentBlockID];
        InterlockedMin(blockBuffer[cellBuffer[cellId].parentBlockID].centerCellSquareDistance, (int)(pow(cell.gridPosX - block.centerX, 2) + pow(cell.gridPosY - block.centerY, 2)), temp);
    }
}

[numthreads(64, 1, 1)]
void GetBlockCenterGridID(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
    CellStruct cell = cellBuffer[cellId];
    if (cell.dead == 1)
    {
        int temp;
        BlockStruct block = blockBuffer[cellBuffer[cellId].parentBlockID];
        if ((int) (pow(cell.gridPosX - block.centerX, 2) + pow(cell.gridPosY - block.centerY, 2)) == block.centerCellSquareDistance)
        {
            int temp;
            InterlockedMin(blockBuffer[cellBuffer[cellId].parentBlockID].centerGridID, width * cell.gridPosY + cell.gridPosX, temp);
        }
    }
}

[numthreads(64, 1, 1)]
void GetBlockCenterCell(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
    CellStruct cell = cellBuffer[cellId];
    if (cell.dead == 1)
    {
        int temp;
        BlockStruct block = blockBuffer[cellBuffer[cellId].parentBlockID];
        // Do we really nedd the first check since centerGridID IS being set using the distance
        if ((int) (pow(cell.gridPosX - block.centerX, 2) + pow(cell.gridPosY - block.centerY, 2)) == block.centerCellSquareDistance && width * cell.gridPosY + cell.gridPosX == block.centerGridID)
        {
            int temp;
            InterlockedExchange(blockBuffer[cellBuffer[cellId].parentBlockID].centerCellID, cellId, temp);
        }
    }
}

[numthreads(64, 1, 1)]
void ResetCellConnctionsToCenter(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
    cellBuffer[cellId].connectedToCenter = 0;
    if(cellId == blockBuffer[cellBuffer[cellId].parentBlockID].centerCellID)
    {
        cellBuffer[cellId].connectedToCenter = 1;
    }
}

[numthreads(64, 1, 1)]
void ConnectCellToCenter(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
    CellStruct cell = cellBuffer[cellId];
    BlockStruct block = blockBuffer[cell.parentBlockID];
    if (cell.dead == 1)
    {
        int2 gridPos = int2(cellBuffer[cellId].gridPosX, cellBuffer[cellId].gridPosY);
        int2 neighBours[8] = { gridPos + int2(-1, -1), 
                               gridPos + int2(0, -1),
                               gridPos + int2(1, -1),
                               gridPos + int2(-1, 0),
                               gridPos + int2(1, 0),
                               gridPos + int2(-1, 1),
                               gridPos + int2(0, 1),
                               gridPos + int2(1, 1)};

        for (int i = 0; i < 10; i++)
        {
            for (int j = 0; j < 8; j++)
            {
                int2 currentGridPos = neighBours[j];
                if (InGridBounds(currentGridPos.x, currentGridPos.y))
                {
                    int gridId = width * currentGridPos.y + currentGridPos.x;
                    if (grid[gridId].cells[i] > -1 && cellBuffer[grid[gridId].cells[i]].dead == 1 && cellBuffer[grid[gridId].cells[i]].parentBlockID == cellBuffer[cellId].parentBlockID && cellBuffer[grid[gridId].cells[i]].connectedToCenter == 1)
                    {
                        cellBuffer[cellId].connectedToCenter = 1;
                    }
                }
            }
        }
    }
}

[numthreads(64, 1, 1)]
void DestroyDisconnectedCells(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
    CellStruct cell = cellBuffer[cellId];
    BlockStruct block = blockBuffer[cell.parentBlockID];
    if (cellBuffer[cellId].dead == 1 && cellBuffer[cellId].connectedToCenter == 0 && InGridBounds(cell.gridPosX, cell.gridPosY) && block.centerCellID > -1 && InGridBounds(cellBuffer[block.centerCellID].gridPosX, cellBuffer[block.centerCellID].gridPosY))
    {
        cellBuffer[cellId].dead = 0;
        cellBuffer[cellId].dying = 1;
    }
}

[numthreads(64, 1, 1)]
void TickBlock(uint3 id : SV_DispatchThreadID)
{
	int blockId = id.x;
	if (blockBuffer[blockId].dead == 1)
	{
		blockBuffer[blockId].currentTick++;
        int factor = 1;
        if (blockBuffer[blockId].velocityX != 0 && blockBuffer[blockId].velocityY != 0)
        {
            factor = 2;
        }
        if (blockBuffer[blockId].currentTick >= blockBuffer[blockId].moveTicks * factor)
		{
			blockBuffer[blockId].canMove = 1;
		}
	}
}

[numthreads(1, 1, 1)]
void SetVelocityById(uint3 id : SV_DispatchThreadID)
{
    VelocityData data = setVelocityBuffer[id.x];
    int blockId = data.blockId;
    blockBuffer[blockId].velocityX = data.velocityX;
    blockBuffer[blockId].velocityY = data.velocityY;
    blockBuffer[blockId].currentTick = blockBuffer[blockId].moveTicks * (abs(data.velocityX) + abs(data.velocityY));
}

[numthreads(1, 1, 1)]
void SetRotationById(uint3 id : SV_DispatchThreadID)
{
    VelocityData data = setVelocityBuffer[id.x];
    int blockId = data.blockId;
    blockBuffer[blockId].rotateDirection = data.rotationDirection;
}

[numthreads(64, 1, 1)]
void CheckShapeMatch(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
	// Get Cell
    CellStruct cell = cellBuffer[cellId];
	//Get Block
    BlockStruct block = blockBuffer[cell.parentBlockID];

}

[numthreads(64, 1, 1)]
void CheckBlockCollisions(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
	// Get Cell
    CellStruct cell = cellBuffer[cellId];
	//Get Block
    BlockStruct block = blockBuffer[cell.parentBlockID];
	// If Cell is alive	and block can move
    if (cell.dead == 1)
    {
        int destGridX = cell.gridPosX;
        int destGridY = cell.gridPosY;

        if (block.rotateDirection != 0)
        {
            destGridX = block.rotateDirection * (cell.gridPosY - block.centerY) + block.centerX;
            destGridY = -block.rotateDirection * (cell.gridPosX - block.centerX) + block.centerY;
        }        

        if (block.canMove == 1)
        {
            // To check where I am moving to
            destGridX += block.velocityX;
            destGridY += block.velocityY;
        }

			// If destination is in bounds
        if ((cell.gridPosX != destGridX || cell.gridPosY != destGridY) && InGridBounds(destGridX, destGridY))
        {
            GridCell gridAhead = grid[width * destGridY + destGridX];
		    // If the grid ahead is occupied by at least 1
            for (int i = 0; i < 10; i++)
            {
                if (gridAhead.cells[i] > -1)
                {
                    BlockStruct blockAhead = blockBuffer[cellBuffer[gridAhead.cells[i]].parentBlockID];
                    	// If it is same type but not same block
                    if (block.subType == blockAhead.subType && block.ID != blockAhead.ID && blockAhead.absorbType != block.ignoreType)
                    {
                    // If they can both absorb and be absorbed
                        if (block.canAbsorb && block.CanBeAbsorbed && blockAhead.canAbsorb && blockAhead.CanBeAbsorbed)
                        {
                        // If priorities match
                            if (block.absorbPriority == blockAhead.absorbPriority)
                            {
                            // Set the lesser creation ID as the absorbee
                                if (block.creationID < blockAhead.creationID)
                                {
                                    int2 attatchPair = int2(block.ID, blockAhead.ID);
                                    attatchBlocksBuffer.Append(attatchPair);
                                }
                                else
                                {
                                    int2 attatchPair = int2(blockAhead.ID, block.ID);
                                    attatchBlocksBuffer.Append(attatchPair);
                                }
                            }
                        // Else choose lesser priority to be absorbee
                            else if (block.absorbPriority < blockAhead.absorbPriority)
                            {
                                int2 attatchPair = int2(block.ID, blockAhead.ID);
                                attatchBlocksBuffer.Append(attatchPair);
                            }
                            else
                            {
                                int2 attatchPair = int2(blockAhead.ID, block.ID);
                                attatchBlocksBuffer.Append(attatchPair);
                            }

                        }
                    // Otherwise set it to whichever can be absorbed
                        else if (block.canAbsorb && blockAhead.CanBeAbsorbed)
                        {
                            int2 attatchPair = int2(blockAhead.ID, block.ID);
                            attatchBlocksBuffer.Append(attatchPair);
                        }
                        else if (blockAhead.canAbsorb && block.CanBeAbsorbed)
                        {
                            int2 attatchPair = int2(block.ID, blockAhead.ID);;
                            attatchBlocksBuffer.Append(attatchPair);
                        }
                    }					
                }
            }
        }
    }
}

[numthreads(64, 1, 1)]
void UpdateAttatchBlockID(uint3 id : SV_DispatchThreadID)
{
    int blockId = attatchBlocksBufferCurated[id.x].x;
    if (blockId > -1)
    {
        blockBuffer[blockId].attachToBlockId = attatchBlocksBufferCurated[id.x].y;
    }
}

[numthreads(64, 1, 1)]
void AttatchBlockCells(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
    if (cellBuffer[cellId].dead == 1 && blockBuffer[cellBuffer[cellId].parentBlockID].attachToBlockId > -1)
    {
        cellBuffer[cellId].parentBlockID = blockBuffer[cellBuffer[cellId].parentBlockID].attachToBlockId;
    }
}

[numthreads(64, 1, 1)]
void MoveCells(uint3 id : SV_DispatchThreadID)
{
	int cellId = id.x;
    if(cellBuffer[cellId].dead == 1)
    {
        int destGridX = cellBuffer[cellId].gridPosX;
        int destGridY = cellBuffer[cellId].gridPosY;

        if (blockBuffer[cellBuffer[cellId].parentBlockID].rotateDirection != 0)
        {
            destGridX = blockBuffer[cellBuffer[cellId].parentBlockID].rotateDirection * (cellBuffer[cellId].gridPosY - blockBuffer[cellBuffer[cellId].parentBlockID].centerY) + blockBuffer[cellBuffer[cellId].parentBlockID].centerX;
            destGridY = -blockBuffer[cellBuffer[cellId].parentBlockID].rotateDirection * (cellBuffer[cellId].gridPosX - blockBuffer[cellBuffer[cellId].parentBlockID].centerX) + blockBuffer[cellBuffer[cellId].parentBlockID].centerY;
        }

        if (blockBuffer[cellBuffer[cellId].parentBlockID].canMove == 1)
        {
            destGridX += blockBuffer[cellBuffer[cellId].parentBlockID].velocityX;
            destGridY += blockBuffer[cellBuffer[cellId].parentBlockID].velocityY;
        }

        cellBuffer[cellId].gridPosX = destGridX;
        cellBuffer[cellId].gridPosY = destGridY;

        if (!InGridBoundsPadded(cellBuffer[cellId].gridPosX, cellBuffer[cellId].gridPosY, min(width, height)))
        {
            cellBuffer[cellId].dead = 0;
        }
    }    
}

// Do grid refresh first
[numthreads(64, 1, 1)]
void PostMoveKillNonMatchingCells(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
    if(InGridBounds(cellBuffer[cellId].gridPosX, cellBuffer[cellId].gridPosY))
    {
        int gridId = width * cellBuffer[cellId].gridPosY + cellBuffer[cellId].gridPosX;
        for (int i = 0; i < 10; i++)
        {
            if (cellBuffer[cellId].dead == 1 && grid[gridId].cells[i] > -1 && grid[gridId].cells[i] != cellId && blockBuffer[cellBuffer[cellId].parentBlockID].subType != blockBuffer[cellBuffer[grid[gridId].cells[i]].parentBlockID].subType)
            {
                if (blockBuffer[cellBuffer[cellId].parentBlockID].KillableByNonMatching == 1 && blockBuffer[cellBuffer[grid[gridId].cells[i]].parentBlockID].KillNonMatching == 1)
                {
                    cellBuffer[cellId].dead = 0;
                    cellBuffer[cellId].dying = 1;
                }
            }
        }
    }    
}

[numthreads(64, 1, 1)]
void PostMoveKillOutgoingCells(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
    if (cellBuffer[cellId].dead == 1 && !InGridBoundsPadded(cellBuffer[cellId].gridPosX, cellBuffer[cellId].gridPosY, min(width, height)))
    {
        cellBuffer[cellId].dead = 0;
    }

}

[numthreads(64, 1, 1)]
void ResetBlockDeathAndMove(uint3 id : SV_DispatchThreadID)
{
    int blockId = id.x;
    blockBuffer[blockId].aboutToDie = blockBuffer[blockId].dead;
    blockBuffer[blockId].dead = 0;
    blockBuffer[blockId].rotateDirection = 0;
    if (blockBuffer[blockId].canMove == 1)
    {
        blockBuffer[blockId].canMove = 0;
        blockBuffer[blockId].currentTick = 0;
    }
}

[numthreads(64, 1, 1)]
void RefreshBlockDeath(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;
    if (cellBuffer[cellId].dead == 1)
    {
        int temp;
        InterlockedExchange(blockBuffer[cellBuffer[cellId].parentBlockID].dead, 1, temp);
        InterlockedExchange(blockBuffer[cellBuffer[cellId].parentBlockID].aboutToDie, 0, temp);
    }
}

[numthreads(64, 1, 1)]
void Detonate(uint3 id : SV_DispatchThreadID)
{
    int blockId = id.x;
    if (blockBuffer[blockId].aboutToDie * blockBuffer[blockId].isGrenade == 1)
    {
        //int2 bottomLeft = int2(cellBuffer[blockBuffer[blockId].centerCellID].gridPosX - detonationRadius, cellBuffer[blockBuffer[blockId].centerCellID].gridPosY - detonationRadius);
        //int2 bottomLeft = int2(cellBuffer[blockBuffer[blockId].centerCellID].gridPosX, cellBuffer[blockBuffer[blockId].centerCellID].gridPosY);

        int x = blockBuffer[blockId].centerX - detonationRadius + id.y;
        int y = blockBuffer[blockId].centerY - detonationRadius + id.z;
        if (InGridBounds(x, y) && pow((int)id.y - detonationRadius, 2) + pow((int) id.z - detonationRadius, 2) <= detonationRadius * detonationRadius)
        {
            int gridId = width * y + x;
            for (int i = 0; i < 10; i++)
            {
                if (grid[gridId].cells[i] > -1 && blockBuffer[cellBuffer[grid[gridId].cells[i]].parentBlockID].subType != blockBuffer[blockId].subType)
                {
                    cellBuffer[grid[gridId].cells[i]].dead = 0;
                    cellBuffer[grid[gridId].cells[i]].dying = 1;
                    cellBuffer[grid[gridId].cells[i]].isImpactDeath = 1;
                    float deltaX = 0.125 * ((cellBuffer[grid[gridId].cells[i]].lastX / scalingFactor) - blockBuffer[blockId].centerX);
                    float deltaY = 0.125 * ((cellBuffer[grid[gridId].cells[i]].lastY / scalingFactor) - blockBuffer[blockId].centerY);
                    //float deltaX = 0;
                    //float deltaY = 0;
                    
                    //deltaX += blockBuffer[blockId].velocityX * 1;
                    //deltaY += blockBuffer[blockId].velocityY * 1;

                    deltaX *= 1 - pow(frac(((float) rand_lcg(id.y + id.z))) / 1000.0, 1);
                    deltaY *= 1 - pow(frac(((float) rand_lcg(rand_lcg(id.y + id.z)))) / 1000.0, 1);

                    cellBuffer[grid[gridId].cells[i]].velocityX = sign(deltaX) * 2000.0 / pow(max(1, abs(deltaX)), 2);
                    cellBuffer[grid[gridId].cells[i]].velocityY = sign(deltaY) * 3000.0 / pow(max(1, abs(deltaY)), 2);
                    cellBuffer[grid[gridId].cells[i]].timeSinceImpact = 0;

                }
            }
        }
    }
}

[numthreads(16, 9, 1)]
void ClearDisplay(uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = float4(0, 0, 0, 0);
}

[numthreads(16, 9, 1)]
void DisplayCells(uint3 id : SV_DispatchThreadID)
{
    int x = floor(id.x / scalingFactor);
    int y = floor(id.y / scalingFactor);
    int gridId = width * y + x;

    if (InGridBounds(x, y))
    {
        for (int i = 0; i < 10; i++)
        {
            int cellId = grid[gridId].cells[i];

            if (cellId >= 0 && cellBuffer[cellId].dead == 1)
            {
                float deltaX = x * scalingFactor - cellBuffer[cellId].lastX;
                float deltaY = y * scalingFactor - cellBuffer[cellId].lastY;

                float u = (float) id.x / (float) scalingFactor - (float) x;
                float v = (float) id.y / (float) scalingFactor - (float) y;
                
                Result[id.xy - int2(deltaX, deltaY)] = cellSprite.SampleLevel(sampler_cellSprite, float2(u, v), 3) * GetColorFromType(blockBuffer[cellBuffer[cellId].parentBlockID].subType);
                if (cellId == blockBuffer[cellBuffer[cellId].parentBlockID].centerCellID)
                {
                    float4 col = debugSprite.SampleLevel(sampler_debugSprite, float2(u, v), 0);
                    if (col.a > 0)
                    {
                        Result[id.xy - int2(deltaX, deltaY) + int2(0, scalingFactor * 0.5)] = debugSprite.SampleLevel(sampler_debugSprite, float2(u, v), 0);
                    }
                }
                if (cellBuffer[cellId].gridPosY - cellBuffer[blockBuffer[cellBuffer[cellId].parentBlockID].centerCellID].gridPosY == 1 && cellBuffer[cellId].gridPosX == cellBuffer[blockBuffer[cellBuffer[cellId].parentBlockID].centerCellID].gridPosX)
                {
                    float4 col = debugSprite.SampleLevel(sampler_debugSprite, float2(u, v), 0);
                    if (col.a > 0)
                    {
                        Result[id.xy - int2(deltaX, deltaY) + int2(0, -scalingFactor * 0.5)] = debugSprite.SampleLevel(sampler_debugSprite, float2(u, v), 0);
                    }
                }
                int playerIdDelta = abs(sign(cellBuffer[cellId].parentBlockID - player1ID));
                if (playerIdDelta == 0 && ((u < 0.3 && InGridBounds(x - 1, y) && grid[gridId - 1].cells[0] < 0) ||
                    (u > 0.7 && InGridBounds(x + 1, y) && grid[gridId + 1].cells[0] < 0) ||
                    (v < 0.3 && InGridBounds(x, y - 1) && grid[gridId - width].cells[0] < 0) ||
                    (v > 0.7 && InGridBounds(x, y + 1) && grid[gridId + width].cells[0] < 0)))
                {
                    Result[id.xy - int2(deltaX, deltaY)] = float4(1, 1, 1, 1);
                }
                if ((u < 0.1 + (1 - playerIdDelta) * 0.1 && InGridBounds(x - 1, y) && grid[gridId - 1].cells[0] < 0) ||
                    (u > 0.9 - (1 - playerIdDelta) * 0.1 && InGridBounds(x + 1, y) && grid[gridId + 1].cells[0] < 0) ||
                    (v < 0.1 + (1 - playerIdDelta) * 0.1 && InGridBounds(x, y - 1) && grid[gridId - width].cells[0] < 0) ||
                    (v > 0.9 - (1 - playerIdDelta) * 0.1 && InGridBounds(x, y + 1) && grid[gridId + width].cells[0] < 0))
                {
                    Result[id.xy - int2(deltaX, deltaY)] = float4(0,0,0,1);
                }
                
            }
        }
    }
}

[numthreads(16, 9, 1)]
void DisplayCenterPins(uint3 id : SV_DispatchThreadID)
{
    int x = floor(id.x / scalingFactor);
    int y = floor(id.y / scalingFactor);
    int gridId = width * y + x;

    if (InGridBounds(x, y))
    {
        for (int i = 0; i < 10; i++)
        {
            int cellId = grid[gridId].cells[i];
            float deltaX = x * scalingFactor - cellBuffer[cellId].lastX;
            float deltaY = y * scalingFactor - cellBuffer[cellId].lastY;
            if (cellId >= 0 && cellBuffer[cellId].dead == 1)
            {
                float u = (float) id.x / (float) scalingFactor - (float) x;
                float v = (float) id.y / (float) scalingFactor - (float) y;
                
                if (cellId == blockBuffer[cellBuffer[cellId].parentBlockID].centerCellID)
                {
                    float4 col = debugSprite.SampleLevel(sampler_debugSprite, float2(u, v), 0);
                    if (col.a > 0)
                    {
                        Result[id.xy - int2(deltaX, deltaY) + int2(0, scalingFactor * 0.5)] = debugSprite.SampleLevel(sampler_debugSprite, float2(u, v), 0);
                    }
                    break;
                }
            }
        }
    }
}

[numthreads(64, 1, 1)]
void LerpCells(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.x;

    int x = cellBuffer[cellId].gridPosX;
    int y = cellBuffer[cellId].gridPosY;

    cellBuffer[cellId].lastX = cellBuffer[cellId].lastX * (1 - 0.5 * cellBuffer[cellId].dead) + x * cellBuffer[cellId].dead * scalingFactor * 0.5;
    cellBuffer[cellId].lastY = cellBuffer[cellId].lastY * (1 - 0.5 * cellBuffer[cellId].dead) + y * cellBuffer[cellId].dead * scalingFactor * 0.5;
        

    x = floor(cellBuffer[cellId].lastX / scalingFactor);
    y = floor(cellBuffer[cellId].lastY / scalingFactor);
    int gridId = width * y + x;
    if (!InGridBounds(x, y) || grid[gridId].cells[0] > -1)
    {
        float fracX = frac(cellBuffer[cellId].lastX / scalingFactor);
        float fracY = frac(cellBuffer[cellId].lastY / scalingFactor);
        cellBuffer[cellId].velocityX = sign(cellBuffer[cellId].velocityX * (frac(cellBuffer[cellId].lastX / scalingFactor) - 0.5)) * 0.8 * cellBuffer[cellId].velocityX;
        cellBuffer[cellId].velocityY = sign(cellBuffer[cellId].velocityY * (frac(cellBuffer[cellId].lastY / scalingFactor) - 0.5)) * 0.8 * cellBuffer[cellId].velocityY;
    }


    cellBuffer[cellId].timeSinceImpact += deltaTime;
    cellBuffer[cellId].lastX += cellBuffer[cellId].velocityX * (1 - cellBuffer[cellId].dead) * deltaTime;
    cellBuffer[cellId].velocityY -= 8000 * deltaTime;
    cellBuffer[cellId].lastY += cellBuffer[cellId].velocityY * (1 - cellBuffer[cellId].dead) * deltaTime;
}

[numthreads(2, 2, 32)]
void DisplayDyingCells(uint3 id : SV_DispatchThreadID)
{
    int cellId = id.z;
    if (cellBuffer[cellId].dead == 0 && cellBuffer[cellId].dying == 1)
    {
        float theta = (float) cellBuffer[cellId].rotTicks * (0.5 * (1 - cellBuffer[cellId].isImpactDeath) + 0.05 * cellBuffer[cellId].isImpactDeath);
        float scale = 1.5 - (0.003 * (1 - cellBuffer[cellId].isImpactDeath) + 0.001 * cellBuffer[cellId].isImpactDeath) * (float) cellBuffer[cellId].rotTicks;
        float offset = 2 * (float) cellBuffer[cellId].rotTicks;
        float originalX = id.x - (float) scalingFactor * 0.5;
        float originalY = id.y - (float) scalingFactor * 0.5;
        float newX = originalX * cos(theta) - originalY * sin(theta);
        float newY = originalX * sin(theta) + originalY * cos(theta);
        newX *= scale;
        newY *= scale;

        if (InGridBounds(cellBuffer[cellId].gridPosX, cellBuffer[cellId].gridPosY))
        {
            float2 uv = float2(id.x, id.y) / (float) scalingFactor;
            Result[uint2(((float) cellBuffer[cellId].lastX / scalingFactor + 0.5) * scalingFactor + newX, ((float) cellBuffer[cellId].lastY / scalingFactor + 0.5) * scalingFactor + newY)] = cellSprite.SampleLevel(sampler_cellSprite, uv, 3) * GetColorFromType(blockBuffer[cellBuffer[cellId].parentBlockID].subType);
           
            if (uv.x < 0.06 || uv.x > 0.94 || uv.y < 0.06 || uv.y > 0.94)
            {
                Result[uint2(((float) cellBuffer[cellId].lastX / scalingFactor + 0.5) * scalingFactor + newX, ((float) cellBuffer[cellId].lastY / scalingFactor + 0.5) * scalingFactor + newY)] = float4(0, 0, 0, 1);
            }
        }
        cellBuffer[cellId].rotTicks++;
        float delX = cellBuffer[cellId].gridPosX - cellBuffer[cellId].lastX / scalingFactor;
        float delY = cellBuffer[cellId].gridPosY - cellBuffer[cellId].lastY / scalingFactor;
        if (scale <= 0)
        {
            cellBuffer[cellId].dying = 0;
        }
    }
}

[numthreads(2, 2, 32)]
void DisplayAimReticle(uint3 id : SV_DispatchThreadID)
{
    int aimArrowId = id.z;
    int directionId = 3 * (aimDirection.y + 1) + aimDirection.x + 1;
    if (aimArrowId < playerAimData[0].directions[directionId])
    {
        float arrowCenterX = ((float) blockBuffer[player1ID].centerX + (float) aimArrowId * (float) aimDirection.x + 0.5) * (float) scalingFactor;
        float arrowCenterY = ((float) blockBuffer[player1ID].centerY + (float) aimArrowId * (float) aimDirection.y + 0.5) * (float) scalingFactor;

        float originalX = id.x - (float) scalingFactor * 0.5;
        float originalY = id.y - (float) scalingFactor * 0.5;
        float factor = pow((float) (aimDirection.x * aimDirection.x + aimDirection.y * aimDirection.y), 0.5);
        float newX = originalX * aimDirection.x + originalY * aimDirection.y;
        float newY = -originalX * aimDirection.y + originalY * aimDirection.x;
        newX /= factor;
        newY /= factor;

        float4 col;
        if (aimArrowId == playerAimData[0].directions[directionId] - 1)
        {
            col = reticleSprite.SampleLevel(sampler_reticleSprite, float2(newX + (float) scalingFactor * 0.5, newY + (float) scalingFactor * 0.5) / ((float) scalingFactor), 0) * GetColorFromType(blockBuffer[player1ID].subType);
            if (col.a > 0)
            {
                Result[uint2(arrowCenterX + originalX, arrowCenterY + originalY)] = col;
            }
        }
        else
        {
            float4 col = arrowSprite.SampleLevel(sampler_arrowSprite, float2(newX + (float) scalingFactor * 0.5, newY + (float) scalingFactor * 0.5) / ((float) scalingFactor), 0) * GetColorFromType(blockBuffer[player1ID].subType);
            if (col.a > 0)
            {
                Result[uint2(arrowCenterX + originalX, arrowCenterY + originalY)] = col;
            }
        }        
    }
}


[numthreads(8, 9, 8)]
void DisplayBlockDebug(uint3 id : SV_DispatchThreadID)
{
	int x = id.x;
	int y = id.y;

	float u = (float)id.x / (float)scalingFactor - (float)x;
	float v = (float)id.y / (float)scalingFactor - (float)y;

	if (blockBuffer[id.z].dead == 1)
	{
		if (blockBuffer[id.z].left == x &&  y <= blockBuffer[id.z].up && y >= blockBuffer[id.z].down)
		{
			DebugResult[id.xy] = float4(1, 0, 0, 0.8);
		}

		if (blockBuffer[id.z].right == x && y <= blockBuffer[id.z].up && y >= blockBuffer[id.z].down)
		{
			DebugResult[id.xy] = float4(0, 1, 0, 0.8);
		}

		if (blockBuffer[id.z].up == y && x <= blockBuffer[id.z].right && x >= blockBuffer[id.z].left)
		{
			DebugResult[id.xy] = float4(0, 0, 1, 0.8);
		}

		if (blockBuffer[id.z].down == y && x <= blockBuffer[id.z].right && x >= blockBuffer[id.z].left)
		{
			DebugResult[id.xy] = float4(1, 1, 0, 0.8);
		}

		if (blockBuffer[id.z].centerX == x && blockBuffer[id.z].centerY == y)
		{
			DebugResult[id.xy] = float4(1, 0.5, 0, 1);
		}
	}
}